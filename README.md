# Learning C
Following examples and advice from [this book](http://ptgmedia.pearsoncmg.com/images/9780789751997/samplepages/0789751992.pdf)


## Lesson 1 Notes

### Brief history of C
Created by Dennis Ritchie at Bell Telephone Laboratories in 1972. It was created for the specific purpose of designing the UNIX operating system. Different versions of C were being used in many different areas, there were some headaches because of this. The American National Standards Institute (ANSI) formed a committee in 1983 to establish a standard definition of C, which became known as ANSI Standard C.

Why the name C? Its predecessor was called B. B was developed by Ken Thompson of Bell Labs. It was named B because of Bell Labs.

Interesting, don't have to label files .c, but it's recommended. Eh, I'm not sure about this. Just tested it and got error
<pre>
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</pre>

### The Compiler
Translates your C code into machine language. The machine language generated by the compiler is called object code, and the disk file containing them is an object file.

My compiler on mac is gcc, installed with X-code

### The Linker
Takes one or more object files generated by a compiler and combines them into one executable program.
I believe that the linker is used even with I only write one .c file because it has to link my program with the built-in C libraries. 

My linker on mac is ld. Not really sure how to use this yet.

## Lesson 2 Notes

Looking at ``bigyear.c``, let's discuss the programs components.

The ``main()`` function - The only component required in every executable C program. Passing ``void`` is not necessary in all compilers, but the ANSI compiler recommends including it to show there is nothing sent to the ``main`` function. Per the ANSI Standard, the only statement one needs to include is the ``return`` statement.

In C, a variable must be defined before it can be used.

### How to debug a C program from the terminal? GDB? LLDB?

I'm reading about something called gdb. The GNU Debugger (GDB), a portable debugger. GDB offers extensive facilities for tracing and altering the execution of computer programs. The user can monitor and modify the values of programs' internal variables, and even call functions independently of the program's normal behavior.

GDB target processors (as of 2003 ( we out here )) include: Alpha, ARM, AVR, H8/300, Altera Nios/Nios II, System/370, System 390, X86 and its 64-bit extension X86-64, IA-64 "Itanium", Motoral 68000, MIPS, PA-RISC, PowerPC, SuperH, SPARC, and VAX. Less-known target processors supported in the standard release have included A29K, ARC, ETRAX CRIS, D10V, D30V, FR-30, FR-V, Intel i960, 68HC11, Motorola 88000, MCORE, MN10200, MN10300, NS32K, Stormy16, and Z8000. (Newer releases will likely not support some of these.) GDB has compiled-in simulators for even lesser-known target processors such like M32R or V850.

GDB is still actively developed. As of version 7.0 new features include support for Python scripting and as of version 7.8 GNU Guile scripting as well. Since version 7.0, support for "reversible debugging" -- allowing a debugging session to step backward, much like rewinding a crashed program to see what happened -- is available.

This debugger seems kind of awful honestly. I read online about good debugger and people say just learn to code you shouldn't have to debug. The hell is the C community on about? What are these people? Just don't write bugs and then you don't need a debugger? This is insanity.

Giving up on this for now, seems difficult. Having issues with gdb not being codesigned.
Unable to find Mach task port for process-id 2002: (os/kern) failure (0x5).
    (please check gdb is codesigned - see taskgated(8))

Alright, got lldb working. We out here.

This list_it.c uses fgets function... Reading the doc [here](https://devdocs.io/c/io/fgets).

<pre>
char *fgets( chat *str, int count, FILE *stream);

Reads at most ``counts - 1`` characters from the given file stream and stores them in the character array pointed to by ``str``. Parsing stops if end-of-file occurs or a newline character is found, in which case ``str`` will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to ``str``.

The behavior is undefined if ``count`` is less than 1.
</pre>
