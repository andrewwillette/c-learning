# Learning C
Following examples and advice from [this book](http://ptgmedia.pearsoncmg.com/images/9780789751997/samplepages/0789751992.pdf)


## Lesson 1 Notes

### Brief history of C
Created by Dennis Ritchie at Bell Telephone Laboratories in 1972. It was created for the specific purpose of designing the UNIX operating system. Different versions of C were being used in many different areas, there were some headaches because of this. The American National Standards Institute (ANSI) formed a committee in 1983 to establish a standard definition of C, which became known as ANSI Standard C.

Why the name C? Its predecessor was called B. B was developed by Ken Thompson of Bell Labs. It was named B because of Bell Labs.

Interesting, don't have to label files .c, but it's recommended. Eh, I'm not sure about this. Just tested it and got error
<pre>
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</pre>

### The Compiler
Translates your C code into machine language. The machine language generated by the compiler is called object code, and the disk file containing them is an object file.

My compiler on mac is gcc, installed with X-code

### The Linker
Takes one or more object files generated by a compiler and combines them into one executable program.
I believe that the linker is used even with I only write one .c file because it has to link my program with the built-in C libraries. 

My linker on mac is ld. Not really sure how to use this yet.

## Lesson 2 Notes

Looking at ``bigyear.c``, let's discuss the programs components.

The ``main()`` function - The only component required in every executable C program. Passing ``void`` is not necessary in all compilers, but the ANSI compiler recommends including it to show there is nothing sent to the ``main`` function. Per the ANSI Standard, the only statement one needs to include is the ``return`` statement.

In C, a variable must be defined before it can be used.

### How to debug a C program from the terminal? GDB? LLDB?

I'm reading about something called gdb. The GNU Debugger (GDB), a portable debugger. GDB offers extensive facilities for tracing and altering the execution of computer programs. The user can monitor and modify the values of programs' internal variables, and even call functions independently of the program's normal behavior.

GDB target processors (as of 2003 ( we out here )) include: Alpha, ARM, AVR, H8/300, Altera Nios/Nios II, System/370, System 390, X86 and its 64-bit extension X86-64, IA-64 "Itanium", Motoral 68000, MIPS, PA-RISC, PowerPC, SuperH, SPARC, and VAX. Less-known target processors supported in the standard release have included A29K, ARC, ETRAX CRIS, D10V, D30V, FR-30, FR-V, Intel i960, 68HC11, Motorola 88000, MCORE, MN10200, MN10300, NS32K, Stormy16, and Z8000. (Newer releases will likely not support some of these.) GDB has compiled-in simulators for even lesser-known target processors such like M32R or V850.

GDB is still actively developed. As of version 7.0 new features include support for Python scripting and as of version 7.8 GNU Guile scripting as well. Since version 7.0, support for "reversible debugging" -- allowing a debugging session to step backward, much like rewinding a crashed program to see what happened -- is available.

This debugger seems kind of awful honestly. I read online about good debugger and people say just learn to code you shouldn't have to debug. The hell is the C community on about? What are these people? Just don't write bugs and then you don't need a debugger? This is insanity.

Giving up on this for now, seems difficult. Having issues with gdb not being codesigned.
Unable to find Mach task port for process-id 2002: (os/kern) failure (0x5).
    (please check gdb is codesigned - see taskgated(8))

Alright, got lldb working. We out here.

This list_it.c uses fgets function... Reading the doc [here](https://devdocs.io/c/io/fgets).

<pre>
char *fgets( chat *str, int count, FILE *stream);

Reads at most ``counts - 1`` characters from the given file stream and stores them in the character array pointed to by ``str``. Parsing stops if end-of-file occurs or a newline character is found, in which case ``str`` will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to ``str``.

The behavior is undefined if ``count`` is less than 1.
</pre>

## Lesson 3 Notes

### Regarding Variable Names

- The name can contain letters (a to z, A to Z), digits (0 to 9), and the underscore character (_)
- The first character of the name must be a letter. The underscore is also a legal first character, but its use is not recommended at the beginning of a name. A digit (0 to 9) cannot be used as the first character.
- Case matters (that is, upper- and lowercase letters). C is case-sensitive, thus, the names ``count`` and ``Count`` refer to two different variables.
- C keywords cannot be used as variable names. A keyword is a word that is part of the C langauge.

C programmers commonly use only lowercase letters in variable names, although this isn't required. Using all uppercase letters is usually reserved for the names of constants.

### Numeric Variable Types

C provides several different types of numeric variables. You need different types of variables because different numeric values have varying memory storage requirements and differ in the ease with which certain mathematical operations can be performed on them. Small integers (for example, 1, 199, and -9) require less memory to store, and your computer can perform mathematical operations (addition, multiplication, and so on) with such numbers quickly. In contrast, large integers and floating-point values (123,000,000, 3.14, or 0.000000871265, for example) require more storage space and more time for mathematical operations. By using the appropriate variable types, you ensure that your program runs as efficiently as possible.

C's numeric variables fall into the following two main categories:
- Integer variables hold values that have no fractional part (that is, whole numbers only). Integer variables come in two flavors, signed integer variables can hold positive or negative values, whereas unsigned integer variables can hold only positive values (and 0).
- Floating-point variables hold values that have a fractional part (that is, real numbers)

|Variable Type|Keyword|Bytes Required|Range|
|-------------|-------|--------------|-----|
|Character|``char``|1|``-128`` to ``127``|
|Short Integer|``short``|2|``-32767`` to ``32767``|
|Integer|``int``|4|``-2,147,483,647`` to ``2,147,483,647``|
|Long integer|``long``|4|``-2,147,483,647`` to ``2,147,483,647``|
|Long long integer|``long long``|8|``-9,223,372,036,854,775,807`` to ``9,223,372,036,854,775,807``|
|Unsigned character|``unsigned char``|1|``0`` to ``255``|
|Unsigned short integer|``unsigned short``|2|``0`` to ``655535``|
|Unsigned integer|``unsigned int``|4|``0`` to ``4,294,967,295``|
|Unsigned long integer|``unsigned long``|4|``0`` to ``4,294,967,295``|
|Unsigned long long integer|``unsigned long long``|8|``0`` to ``18,446,744,073,709,551,615``|
|Single-precision floating-point|``float``|4|``1.2E-38`` to ``3.4E38``|
|Double-precision floating-point|``double``|8|``2.2E-308`` to ``1.8E308^2``|

``int`` and ``long`` look identical. Why is this? The ``int`` and ``long`` indeed are identical on 64-bit Intel systems (PCs), but they might be different on other types of hardware. Remember that C is a flexible, portable language, so it provides different keywords for the two types. If you work on a PC, you can use ``int`` and ``long`` interchangeably.

No special keyword is needed to make an integer variable signed; integer variables are signed by default. You can, however, include the ``signed`` keyword if you want. The keywords show in the above table are used in variable declarations, which we will discuss in the next section.

``sizeof.c`` helps you determine the size of variables on your particular computer. Don't be surprised if your output doesn't match the output presented after the listing.



