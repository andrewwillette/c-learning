# Learning C
Following examples and advice from [this book](http://ptgmedia.pearsoncmg.com/images/9780789751997/samplepages/0789751992.pdf)


## Lesson 1 Notes

### Brief history of C
Created by Dennis Ritchie at Bell Telephone Laboratories in 1972. It was created for the specific purpose of designing the UNIX operating system. Different versions of C were being used in many different areas, there were some headaches because of this. The American National Standards Institute (ANSI) formed a committee in 1983 to establish a standard definition of C, which became known as ANSI Standard C.

Why the name C? Its predecessor was called B. B was developed by Ken Thompson of Bell Labs. It was named B because of Bell Labs.

Interesting, don't have to label files .c, but it's recommended. Eh, I'm not sure about this. Just tested it and got error
<pre>
clang: error: linker command failed with exit code 1 (use -v to see invocation)
</pre>

### The Compiler
Translates your C code into machine language. The machine language generated by the compiler is called object code, and the disk file containing them is an object file.

My compiler on mac is gcc, installed with X-code

### The Linker
Takes one or more object files generated by a compiler and combines them into one executable program.
I believe that the linker is used even with I only write one .c file because it has to link my program with the built-in C libraries. 

My linker on mac is ld. Not really sure how to use this yet.

## Lesson 2 Notes

Looking at ``bigyear.c``, let's discuss the programs components.

The ``main()`` function - The only component required in every executable C program. Passing ``void`` is not necessary in all compilers, but the ANSI compiler recommends including it to show there is nothing sent to the ``main`` function. Per the ANSI Standard, the only statement one needs to include is the ``return`` statement.

In C, a variable must be defined before it can be used.

### How to debug a C program from the terminal? GDB? LLDB?

I'm reading about something called gdb. The GNU Debugger (GDB), a portable debugger. GDB offers extensive facilities for tracing and altering the execution of computer programs. The user can monitor and modify the values of programs' internal variables, and even call functions independently of the program's normal behavior.

GDB target processors (as of 2003 ( we out here )) include: Alpha, ARM, AVR, H8/300, Altera Nios/Nios II, System/370, System 390, X86 and its 64-bit extension X86-64, IA-64 "Itanium", Motoral 68000, MIPS, PA-RISC, PowerPC, SuperH, SPARC, and VAX. Less-known target processors supported in the standard release have included A29K, ARC, ETRAX CRIS, D10V, D30V, FR-30, FR-V, Intel i960, 68HC11, Motorola 88000, MCORE, MN10200, MN10300, NS32K, Stormy16, and Z8000. (Newer releases will likely not support some of these.) GDB has compiled-in simulators for even lesser-known target processors such like M32R or V850.

GDB is still actively developed. As of version 7.0 new features include support for Python scripting and as of version 7.8 GNU Guile scripting as well. Since version 7.0, support for "reversible debugging" -- allowing a debugging session to step backward, much like rewinding a crashed program to see what happened -- is available.

This debugger seems kind of awful honestly. I read online about good debugger and people say just learn to code you shouldn't have to debug. The hell is the C community on about? What are these people? Just don't write bugs and then you don't need a debugger? This is insanity.

Giving up on this for now, seems difficult. Having issues with gdb not being codesigned.
Unable to find Mach task port for process-id 2002: (os/kern) failure (0x5).
    (please check gdb is codesigned - see taskgated(8))

Alright, got lldb working. We out here.

This list_it.c uses fgets function... Reading the doc [here](https://devdocs.io/c/io/fgets).

<pre>
char *fgets( chat *str, int count, FILE *stream);

Reads at most ``counts - 1`` characters from the given file stream and stores them in the character array pointed to by ``str``. Parsing stops if end-of-file occurs or a newline character is found, in which case ``str`` will contain that newline character. If no errors occur, writes a null character at the position immediately after the last character written to ``str``.

The behavior is undefined if ``count`` is less than 1.
</pre>

## Lesson 3 Notes

### Regarding Variable Names

- The name can contain letters (a to z, A to Z), digits (0 to 9), and the underscore character (_)
- The first character of the name must be a letter. The underscore is also a legal first character, but its use is not recommended at the beginning of a name. A digit (0 to 9) cannot be used as the first character.
- Case matters (that is, upper- and lowercase letters). C is case-sensitive, thus, the names ``count`` and ``Count`` refer to two different variables.
- C keywords cannot be used as variable names. A keyword is a word that is part of the C langauge.

C programmers commonly use only lowercase letters in variable names, although this isn't required. Using all uppercase letters is usually reserved for the names of constants.

### Numeric Variable Types

C provides several different types of numeric variables. You need different types of variables because different numeric values have varying memory storage requirements and differ in the ease with which certain mathematical operations can be performed on them. Small integers (for example, 1, 199, and -9) require less memory to store, and your computer can perform mathematical operations (addition, multiplication, and so on) with such numbers quickly. In contrast, large integers and floating-point values (123,000,000, 3.14, or 0.000000871265, for example) require more storage space and more time for mathematical operations. By using the appropriate variable types, you ensure that your program runs as efficiently as possible.

C's numeric variables fall into the following two main categories:
- Integer variables hold values that have no fractional part (that is, whole numbers only). Integer variables come in two flavors, signed integer variables can hold positive or negative values, whereas unsigned integer variables can hold only positive values (and 0).
- Floating-point variables hold values that have a fractional part (that is, real numbers)

|Variable Type|Keyword|Bytes Required|Range|
|-------------|-------|--------------|-----|
|Character|``char``|1|``-128`` to ``127``|
|Short Integer|``short``|2|``-32767`` to ``32767``|
|Integer|``int``|4|``-2,147,483,647`` to ``2,147,483,647``|
|Long integer|``long``|4|``-2,147,483,647`` to ``2,147,483,647``|
|Long long integer|``long long``|8|``-9,223,372,036,854,775,807`` to ``9,223,372,036,854,775,807``|
|Unsigned character|``unsigned char``|1|``0`` to ``255``|
|Unsigned short integer|``unsigned short``|2|``0`` to ``655535``|
|Unsigned integer|``unsigned int``|4|``0`` to ``4,294,967,295``|
|Unsigned long integer|``unsigned long``|4|``0`` to ``4,294,967,295``|
|Unsigned long long integer|``unsigned long long``|8|``0`` to ``18,446,744,073,709,551,615``|
|Single-precision floating-point|``float``|4|``1.2E-38`` to ``3.4E38``|
|Double-precision floating-point|``double``|8|``2.2E-308`` to ``1.8E308^2``|

``int`` and ``long`` look identical. Why is this? The ``int`` and ``long`` indeed are identical on 64-bit Intel systems (PCs), but they might be different on other types of hardware. Remember that C is a flexible, portable language, so it provides different keywords for the two types. If you work on a PC, you can use ``int`` and ``long`` interchangeably.

No special keyword is needed to make an integer variable signed; integer variables are signed by default. You can, however, include the ``signed`` keyword if you want. The keywords show in the above table are used in variable declarations, which we will discuss in the next section.

``sizeof.c`` helps you determine the size of variables on your particular computer. Don't be surprised if your output doesn't match the output presented after the listing.

| Commonly Used Keyword|Full Name|
|----------------------|---------|
|`char`|`signed char`|
|`short`|`signed short int`|
|`int`|`signed int`|
|`long`|`signed long int`|
|`long long`|`signed long long int`|
|`unsigned char`|`unsigned char`|
|`unsigned short`|`unsigned short int`|
|`unsigned int`|`unsigned int`|
|`unsigned long`|`unsigned long int`|
|`unsigned long long`|`unsigned long long int`|

As you can see from this table, _short_ and _long_ types are actually just variations of the _int_ type. Most programmings don't use the full name of the variable types, rather, they use thke shorter version.

### Variable Declarations
Before you can use a variable in the C program, it must be declared. A variable declaration tells the compiler the name and type of a variable. The declaration may also initialize the variable to a specific value. If your program attempts to use a variable that hasn't been declared, the compiler generates an error message. A variable declaration has the following form:
<pre>
typename varname;
</pre>

_typename_ specifies the variable type and must be one of the keywords listed in above table. _varname_ is the variable name, which must follow the rules mentioned earlier. You can declare multiple variables of the same type on one line by separating the varaible names with commas:
<pre>
int count, number, start;
float percent, total;
</pre>

In Lesson 12 , "Understanding Variable Scope", you learn that the location of variable declarations in the source code is important because it affects the ways in which your program can use the variables. For now, you can place all the variable declarations together just before the start of the ``main()`` function.

### The _typedef_ keyword
The _typedef_ keyword is used to create a new name for an existing data type. In effect, _typedef_ creates a synonym. For example, the statement:
<pre>
typedef int integer;
</pre>
creates _integer_ as a synonym for _int_. You then can use _integer_ to definte variables of type _int_, as in this example:
<pre>
integer count;
</pre>
Note that _typedef_ doesn't create a new data type; it enables you to use a different name for only a predefined data type. The most common use of _typedef_ concerns aggregate data types, as explained in Lesson 11, "Implementing Structures, Unions, and TypeDefs." An aggregate data type consists of a combination of data types presented in this lesson. (I am sure you are a bit confused by this last sentence--dont' worry about it; it just means that the _typedef_ keyword will be much more valuable to you after you learn about structures.)

### Initializing Variables
When you declare a variable, you instruct the compiler to set aside storage space for the variable. However, the value stored in that space--the value of the variable--isn't defined. It might be zero, or it might be some random "garbage" value. Before using a variable, you should always initialize it to a known value. You can do this independently of the variable definition by using an assignment statement, as in this example:
<pre>
int count;
count = 0;
</pre>

Note that this statement uses the (=), which is C's assignment operator and is discussed further in Lesson 4, "The Pieces of a C Program: Statements, Expressions, and Operators". For now, you need to be aware that the equal sign in programming is not the same as the equal sign in algebra. If you write
<pre>
x = 12
</pre>
in an algebraic statement, you are stating a fact: "x equals c". In C, however, it means something quite different. In C it means "assign the value 12 to the variable named X".

You can also initialize a variable when it's declared. To do so, follow the variable name in the declaration statement with an equal sign and the wanted initial value:
<pre>
int count = 0;
double percent = 0.01, taxrate = 28.5;
</pre>
The first statement declares a variable called _count_ as an integer and initializes it to 0. The second statement declares two variables as doubles and initalizes them. The first, _percent_, is initialzed to 0.01. The second, _taxrate_, is initialized to _28.5_.

Be careful not to initialize a variable with a value outside the allowed range. Here are two examples of out-of-range initializations:
<pre>
short weight = 100000;
unsigned int value = -2500;
</pre>
The C compiler might not catch such errors. Your program might compile and link, but you might get unexpected results when the program runs.

### Constants
Like a variable, a _constant_ is a data storage location used by your program. Unlike a variable, the value stored in a constant can't be changed during program execution. C has two types of constants, each with its own specific uses:
- Literal constants
- Symbolic constants

#### Literal Constants
A _literal constant_ is a value that is typed directly into the source code where it is needed. Here are two examples:
<pre>
int count = 20;
float tax_rate = 0.28;
</pre>
The _20_ and _0.28_ are literal constants. The preceding statements store these values in the variables _count_ and _tax_rate_. Note that one of these constants contains a decimal point, whereas the other does not. The presence of absence of the decimal point destinguishes floating-point constants from integer constants.

A literal constant written with a decimal point is a floating-point constant and is represented by the C compiler as a double-precision number. Floating-point constants can be written in standard decimal notation, as shown in these examples:
<pre>
123.456
0.019
100.
</pre>
Note that the third constant, _100._, is written with a decimal point even though it's an integer. The decimal point causes the C compiler to treat the constant as a double-precision value. Without the decimal point, it is treated as an integer constant.

Floating-point constants can also be written in scientific notation. You might recall from high school math that scientific notation represents a number as a decimal part multiplied by _10_ to a positive or negative power. Scientific notation is particularly useful for representing extremely large and extremely small values. In C, scientific notation is written as a decimal number followed immediately by an _E_ or _e_ and the exponent.

|`1.23E2`|`1.23 times 10 to the 2nd power, or 123`|
|`4.08e6`|`4.08 times 10 to the 6th power, or 408000`|
|`.85e-4`|`.85 times 10 to the -4th power, or .000085`|
A constant written without a decimal point is represented by the compiler as an integer number. Integer constants can be written in three different notations:

- A constant starting with any digit other than 0 is interpreted as a decimal integer (that is, the standard base-10 number system). Decimal constants can contain the digits 0 to 9 and a leading minus or plus sign. (Without a leading minus or plus sign, a constant is assumed to be positive).
- A constant starting with the digit 0 is interpreted as an octal integer (the base-8 number system). Octal constants can contain the digits 0 through 7 and a leading minus or plus sign.
- A constant starting with _0x_ or _0X_ is interpreted as a hexadecimal constant (the base-16 number system). Hexadecimal constants can contain the digits 0 through 9, the letters A through F, and a leading minus or plus sign.

#### Symbolic Constants
A _symbolic constant_ is a constant represented by a name (symbol) in your program. Like a literal constant, a symbolic constant can't change. Whenever you need the constant's value in your program, you use its name as you would use a variable name. The actual value of the symbolic constant needs to be entered only once, when it is first defined.

Symbolic constants have two significant advantanges over literal constants, as the following example shows. Suppose that you write a program that performs a variety of geometrical calculations. The program frequently needs the value _π_ (3.14) for its calculations. (You might recall from geometry class that _π_ is the ratio of a circle's circumference to its diameter.) For example, to calculate the circumference and area of a circle with a known radiu, you could write
<pre>
circumference = 3.14 * (2 * radius);
area = 3.14 * (radius) * (radius)
</pre>
The asterisk (*) is C's multiplication operator and is covered in Lesson 4. Thus, the first of these statements means "Multiply 2 times the value stored in the variable _radius_, and then multiple the result by 3.14. Finally, assign the result to the variable named _circumference_."

If, however, you define a symbolic constant with the name _PI_ and the value 3.14, you could write 
<pre>
circumference = PI * (2 * radius);
area = PI * (radius)*(radius);
</pre>
The resulting code is clearer. Rather than puzzling over what the value _3.14_ is for, you can see immediately that the constant _PI_ is used.

The second advantage of symbolic constants becomes apparent when you need to change the constant. Continuing with the preceding example, you might decide that for greater accuracy your program needs to use a value of _PI_ with more decimal places: _3.14159_ rather than _3.14_. If you had used literal constants _PI_, you would have to go through your source code and change each occurrence of the value from _3.14_ to _3.14159_. With a symbolic constant, you need to make a change only in the place in which the constant is defined. The rest of your code would not need to be changed.

##### Defining Symbolic Constants
C has two methods for defining a symbolic constant: the ``#define`` directive and the ``const`` keyword. the ``#define`` directive is used as follows:
<pre>
#define CONSTNAME literal
</pre>
This creates a constant named ``CONSTNAME`` with the value of _literal_. _literal_ represents a literal constant, as described earlier. _CONSTNAME_ follows the same rules described earlier for variable names. By convention, the names of symbolic constants are uppercase. This makes them easy to distinguish from variable names, which by convention are lowercase. For the previous example, the required ``#define`` directive for a constant ``PI`` would be 
<pre>
#define PI 3.14159
</pre>
Note that ``#define`` lines don't end with a semicolon (;). ``#define`` statements can be placed anywhere in your source code, but the defined constant is in effect only for the portions of the source code that follow the ``#define`` directive. Most commonly, programmers group all ``#define`` statements together, near the beginning of the file and before the start of the ``main()`` function.

#### How a #define Works
The precise action of the ``#define`` directive is to instruct the compiler as follows: "In the source code, replace ``CONSTNAME`` with ``literal``". The effect is exactly the same as if you had used your editor to through the source code and make the changes manually. Note that ``#define`` doesn't replace instances of its target that occur as parts of longer names, within double quotes, or as part of a program comment. For example, in the following code, the instances of ``PI`` in the second and third lines would not get changed:

<pre>
#define PI 3.14159
/* You have defined a constant for PI */
#define PIPETTE 100
</pre>

#### Defining Constants with the ``const`` keyword
The second way to define a symbolic constant is with the ``const`` keyword. ``const`` is a modifier that can be applied to any variable declaration. A variable declared to be ``const`` can't be modified when the program is executed. A value is initialized at the time of declaration and is then prohibited from being changed. Here are some examples:
<pre>
const int count = 100;
const float pi = 3.14156;
const long debt = 12000000, flat tax_rate = 0.21;
</pre>
``const`` affect all variables on the declaration line. In the last line, ``debt`` and ``tax_rate`` are symbolic constants. As a side note, in this example, ``debt`` was declared as a long and ``tax_rate`` was declared as a float.

If your program tries to modify a ``const`` variable, the compiler generates an error message. The following code would generate an error:
<pre>
const int = 100
count = 200;
</pre>
What are the practical differences between symbolic constants created with the ``#define`` directive and those created with the ``const`` keyword? The differences have to do with the pointers and variable scope. Pointers and variable scope are two important aspects of C programming, and you learn about them in Lesson 9, "Understanding Pointers", and Lesson 12.

Now take a look at a program that demonstrates variable declarations and the use of literal symbolic constants. Listing 3.2 prompts you to enter a number of laps run and year of birth. It then calculates and displays the miles you covered and age this year. You can enter, compile, and run this program using the procedures explained in Lesson 1, "Getting Started with C".

This program demonstrates the two methods you can use to declare symbolic constants. On line 5, the ``#define`` directive sets the value 4 to ``LAPS_PER_MILE``. If you move to a place with a smaller or larger track, you can easily change the information in this one spot, and all code will be updated to calculate information using the new symbolic constant. Line 8 shows a second symbolic constant declaration, one using ``const int``. A current year is another place a defined constant makes sense, as it is something you would need to change only once a year.
Lines 11 and 12 contain the declarations you need for this program's calculations. You need to make ``miles_covered`` a floating-point variable because each lap is one-quarter of a mile (and could change to anything else) and you want to give your user an exact mileage based on how many laps they ran. Line 25 takes the laps entered by the user and calculates the total miles. Using the ``LAPS_PER_MILE`` makes the calculation clearer than just putting a 4 into the statement.
What may not be as clear is the (float) addition to front of ``laps_run``. To understand why that little extra is needed, remove it, rerun the program, and make sure you enter 7 as the number of laps. Surprised? Even though you delcared ``miles_covered`` as a float, dividing two integers puts an integer answer into that variable, but the ``.00`` might make you think otherwise. To make it worse, the value is truncated, and the ``.75`` after the ``1`` is cut off and not rounded up, as ``2.00`` is a more accurate answer. So putting ``(float)`` in front of ``laps_run`` tells the compiler to treat it like a ``float`` instead of an ``int``. Then you get a precise and correct answer.
Lines 18 and 20 print prompts onscreen. The ``printf()`` function is covered in greater detail later. To allow the user to respond to the prompts, lines 19 and 21 use another library function, ``scanf()``, which is covered later. ``scanf()`` gets information from the screen. For now, accept that this works as shown in the listing. Later, you learn exactly how it works. Line 26 calculates what age the user will turn sometime in 2021. Obviously, you cannot answer with detail user's exact ages unless you get the day and month of their birthdays as well ass today's day and month to calculate whether they've celebrated a birthday this year yet. For the purpose of this program, mentioning what age they will become this year is close enough. These statements and others are covered in detail in the next lesson. To finish the program, lines 30 and 31 display the results for the user.

## Lesson 4 - The Pieces of a C Program: Statements, Expressions, and Operators

C programs consist of statements, and most statements are composed of expressions and operators. To write C programs, you need to understand statements, expressions, and operators. In this lesson you learn:
- What a statement is
- What an expression is
- How to use C's mathematical, relational, and logical operators
- What operator precendence is
- The if statment

Some minor notes from this as most of this is basic stuff.

Legal but bad form:
<pre>
printf(
"hello, world!"
);
</pre>

Illegal:
<pre>
printf("Hello,
world!");
</pre>

To break a string constant line, you must use the backslash character (\) just before the break, Thus the following is legal:
<pre>
printf("Hello,\
world!");
</pre>

#### Creating a null statement
If you place a semicolon by itself on a line, you create a null statement. A null statement is one that doesn't perform any action. This is perfectly legal in C. Later in this book, you learn how the null statement can be useful.

#### Compound Statement
A _compound statement_, also called a _block_, is a group of two or more C statements enclosed in braces. Here's an example of a block:
<pre>
{
    printf("hello, ");
    printf("world!");
}
</pre>

In C, a block can be used anywhere a single statement can be used. Many examples of this appear throughout this book. Note that the enclosing braces can be positioned in different ways. The following is equivalent to the preceding example:
<pre>
{printf("hello, ");
printf("world!");}
</pre>
It's a good idea to place braces on their own lines, making the beginning and ending of blocks clearly visible. 
#### Understanding Expressions
In C, an _expression_ is anything that evaluates to a numeric value. C expressions come in all levels of complexity.

Following is a valid expression:
<pre>
y = x = a + 10
</pre>

Following is valid expression:
<pre>
x = 6 + (y = 4 + 5)
</pre>
The result of this is that ``y`` has the value of ``9`` and ``x`` has the value of ``15``. 

#### Operators
An _operator_ is a symbol that instructs C to perform some operation, or action, on one or more operands. An _operand_ is something that an operator acts on. In C, all operands are expressions. C operators fall into several categories:
- Assignment operator
- Mathematical operators
- Relational operators
- Logical operators

##### Assignment Operators
Just the basic 
<pre>
x = y;
</pre>
<pre>
variable = expression;
</pre>
When executed, ``expression`` is evaluated, and the resulting value is assigned to ``variable``.

##### Mathematical Operators

Unary Operators
|Operator|Symbol|Action|Exmaples|
|--------|------|------|--------|
|Increment|++|Increments the operand by one|++x, x++|
|Decrement|--|Decrements the operand by one|--x, x--|

Order of ``x++`` vs ``++x`` matters. To understand this:
<pre>
x = 10;
y = x++;
</pre>
After these statements are executed, ``x`` has the value ``11`` and ``y`` has the value ``10``.

<pre>
x = 10;
y = ++x;
</pre>
This statement resolves to both ``x`` and ``y`` have the value ``11``.

``unary.c`` illustrates the difference between prefix mode and postfix mode.

##### Binary Mathematical Operators

|Operator|Symbol|Action|Example|
|--------|------|------|-------|
|Addition|+|Adds two operands|x + y|
|Subtraction|-|Subtracts the second operand from the first operand|x - y|
|Multiplication|*|Multiplies two operands|x * y|
|Division|/|Divides the first operand by the second operand|x / y|
|Modulus|%|Gives the remainder when the first operand is divided by the second operand|x % y|

``seconds.c`` illustrates how you can use the modulus operator to convert a large number of seconds into hours, mintues, and seconds.

##### Operator precedence

|Operators|Relative Precedence|
|---------|-------------------|
|++ --|1|
|* / %|2|
|+ -|3|

Alright, enough of these baby lessons. I only have so much life in me.


## Lesson 9 - Understanding Pointers

### What is a pointer?
To understand pointers, you need a basic knowledge of how your computer stores information in memory. The following is a somewhat simplified account of PC memory storage.

A PC's memory (RAM) consists of many millions of sequential sotrage locations, and each locaiton is identified by a unique address. The memory addresses in a given computer range from zero to a maximum value that depends on the amount of memory installed.

When you use your computer, the operating system uses some of the system's memory. When you run a program, the program's code (the machine-language instructions for the program's various tasks) and data (the information the program uses) also use some of the system's memory. This section examines the memory storage for program data.

When you declare a variable in a C program, the compiler sets aside a memory location with a unique address to store that variable. The compiler associates that address with the variable's name. When your program uses the variable name, it automatically accesses the proper memory location. The location's address is used, but it is hidden from you, and you need not be concerned with it.

### Creating a pointer
You should not that the address of any variable is a number cand can be treated like any other number in C. If you know a variable's address, you can create a second variable in which to store the address of the first. Given a variable named ``rate``, the first step is to declare a variable to hold the address of ``rate``. Give it the name ``p_rate``, for example. At first, ``p_rate`` is uninitialized. Storage has been allocated for ``p_rate``, but its value is undetermined.

The next step is to store the address of the variable ``rate`` in the variable ``p_rate``. Because ``p_rate`` now contains the address of ``rate``, it indicates the location in which ``rate`` is stored in memory. In C parlancew, ``p_rate`` _points_ to ``rate``, or is a pointer to ``rate``.

To summarize, a pointer is a variable that contains the address of another variable. Now you can get down to the details of using pointers in your C programs.

Note: How is this useful at all? To get the address to set the pointer, I'm guessing I have to call ``rate.address`` or something. So why store it? I'm sure there's a reason... the author should have said it but alas. He probably will soon.

### Pointers and Simple Variables

#### Declaring Pointers
A pointer is a numeric variable and, like all variables, must be declared before it can be used. Pointer variable names follow the same rules as other variables and must be unique. This lesson uses the convention that a pointer to the variable ``name`` is called ``p_name``. This isn't necessary, however; you can name pointers anything you want as long as they follow C's naming rules. A point declaration takes the following for:
<pre>
typename *ptrname;
</pre>
where ``typename`` is any of C's variable types and indicates the type of the variable that the pointer points to. The asterisk (*) is the indirection operator, and it indicates that ``ptrname`` is a pointer to ``typename`` and not a variable of type ``typename``. Pointers can be declared along with nonpointer variables. Here are some more examples:
<pre>
char *ch1, *ch2; /* both of these are pointers to type char */
float *value, percent; /* value is a pointer to type float, percent is normal variable of type float */
</pre>

#### Initializing Pointers
The address doesn't get stored in the pointer by magic; your program must put it there by using the address-of operator, the ampersand (&). When placed before the name of a variable, the address-of operator returns the address of the variable. Therefore, you initialize a pointer with a statement of the form
<pre>
pointer = &variable
</pre>

#### Using Pointers

Consider the statement:
<pre>
*p_rate = &rate;
</pre>

If you write ``*p_rate``, this pointer variable refers to the contents of the variable ``rate``. If you want to print the value of ``rate``, you could write
<pre>
printf("%d", rate);
</pre>
or you could write this statement:
<pre>
printf("%d", *p_rate);
</pre>

In C, these two statements are equivalent. Accessing the contents of a variable by using the variable is called _direct access_. Accessing the contents of a variable by using a pointer to the variable is called _indirect access_ or _indirection_.

``pointer.c`` demonstrates basic pointer usage.

How do pointers handle the addresses of multibyte variables? Here's how: The address of a variable is actually the address of the first (lowest) byte it occupies. This is why you need to declare what type the pointer references. So it knows how many bytes to look at when checking it.

### Pointers and Arrays
#### The Array Name as a Pointer
An array name without brackets is a pointer to the array's first element. Thus, if you declare an array ``data[]``, ``data`` is the address of the first array element. Yes, normally you use the ``&`` to get the address of something. In this case, ``&data[0]`` is equivalent to ``data``.

You've seen that the name of an array is a pointer to the array. The name of an array is a pointer constant; it can't be changed and remains fixed for the entire time the program executes. This makes sense: If you changed its value, it would point elsewhere and not to the array.

Below is valid pointer declaration:
<pre>
int array[100], *p_array;
p_array = array;
</pre>

### Array Element Storage
Elements of an array are stored in sequential memory locations fwith the first element in the lowest address. Subsequent array elements are stored in higher addresses. How much higher depends on the array's data type.

How do access successive array elements using a pointer? A pointer must be increased by ``sizeof(datatype)``. See ``counter.c`` for example.

Interesting that the books version seems to be printing out decimal values while my machine is printing out hexadecimal. Glad I'm printing out hexadecimal, I was thinking that's how memory addresses were getting printed out.

### Pointer Arithmetic
One really only has to be concerned with two pointer operations: incrementing and decrementing.

When incrementing a pointer to an array (``ptr_to_short++``), the value is increased by the number of bytes of the type the pointer is declared as. C does this automatically.

The same holds true for increments greater than 1. If you add the value _n_ to a pointer, C increments the pointer by _n_ array elements of the associated data type. Therefore,
<pre>
ptr_to_short += 4;
</pre>
increases the ``ptr_to_short`` by 8 (2 bytes per _short_ type). 

Likewise,
<pre>
ptr_to_float += 10;
</pre>
increases the value stored in ``ptr_to_float`` by 40 (4 bytes per _float_ type).

Decrementing pointers is the same concept. See ``ptr_math.c`` for some example usage.

It seems like if I increase the loop size beyond ``MAX``, it keeps increasing at the same rate.
I'm wrong. I don't know what I was seeing before, but it appears this is not actually the case. I wonder if I can set a value at a memory location and print that memory location. I'll fiddle with this another time.

### Other Pointer Manipulations
The other pointer arithmetic operation that you want to use is called _differencing_, which refers to subtracting two pointers. If you have two pointers to different elements of the same array, you can subtract them and find out how far apart they are. 

So if ``ptr1`` and ``ptr2`` point to elements of an array (of any type), the following expression tells you how far apart the elements are:
<pre>
ptr1 - ptr2
</pre>

You can also compare pointers. Pointer comparisons are valid only between pointers that point to the same array.
<pre>
ptr1 < ptr2
</pre>
is true if ``ptr1`` points to an earlier member of the array that ``ptr2`` does.

This covers all allowed pointer operations. Many arithmetic operations that can be performed with regular variables, such as multiplication and division, don't make sense with pointers. The C compiler doesn't allow them.

### Pointer Cautions
This is dangerous:
<pre>
int *ptr;
*ptr = 12;
</pre>
The value ``12`` is assigned to whatever address ``ptr`` points to. That address can be almost anywhere in memory--where the operating system is stored or somewhere in the program's code. It could overwrite some important information, and the result can be anything from strange program errors to a full system crash.
The important thing to do/understand is to be sure your program's pointers are properly initialzied before you use them. You must do this yourself; don't assume the compiler will do this for you.

### Array Subscript Notation and Pointers
An array name without brackets is a pointer to the array's first element. Therefore, you can access the first array element using the indirection operator. If ``array[]`` is a declared array, the expression ``*array`` is the array's first element, ``*(array + 1)`` is the array's second element, and so on. If you generalize the entire array, following relationships hold true:
<pre>
*(array) == array[0]
*(array + 1) == array[1]
*(array + 2) == array[2]
...
*(array + n) == array[n]
</pre>
This illustrates the equivalence of array subscript notation and array pointer notation. You can use either in your programs; the C compiler sees them as two different ways of accessing array data using pointers.

### Passing Arrays to Functions
The only way you can pass an array to a function is by using a pointer. Weird but ok. I'm sure there's a reason.

An argument is a value that the calling program passes to a function. It can be an ``int``, a ``float``, or any other simple data type, but it must be a single numberical value. It can be a single array element, but it can't be an entire array. Okay, so that's why it's necessary to just provide a pointer, I can't give a bunch of arguments to a function, only one. Just the pointer.

Consider this problem then: If you write a function that takes an array as an argument, you want a function that can handle arrays of different sizes. For example, a function which finds the largest element in an array of integers. The function wouldn't be much use if it were limited to dealing with arrays of one fixed size.

How does the function know the size of the array whose address it was passed? Remember, the value passed to a function is a pointer to the first array element. It could be 10 elements or 10,000. There are two methods of letting a function know an array's size.

You can identify the last array element by storing a special value there. As the function processes the array, it looks for that value in each element. When the value is found, the end of the array has been reached. The disadvantage of this method is that it forces you to reserve a value as the end-of-array indicator, reducing the flexibility you have for storing real data in the array.

The other method is more flexible and straightforward, and it's the one used in this book: Pass the function the array size as an argument. This can be a simple time ``int`` argument. Thus, the function is passed two arguments: a pointer to the first array element and an integer specifying the number of elements in the array.

``arraypass.c`` accepts a list of values from the user and stores them in an array. It then calls a function named ``largest()``, passing the array (both pointer and size). The function finds the largest value in the array and returns it to the calling program.

## Lesson 11 - Implementing Structures, Unions, and TypeDefs
A structure is a data storage type designed by you, the programmer, to suit your programming needs exactly. In this lesson you learn
- What simple and complex structures are
- How to define and declare structures
- How to access data in structures
- How to create structures that contain arrays and arrays of structures
- How to declare pointers in structures and pointers to structures
- How to pass structures as arguments to functions
- How to define, declare, and use unions
- How to use type definitions with structures

### Working with Simple Strucutres
A _structure_ is a collection of one or more variables grouped under a single name for easy manipulation. The variables in a structure, unlike those in an array, can be of different data types. Each variable within a structure is called a _member_ of the structure. The next section shows a simple example.
You should start with simple structures. Note that C language makes no distinction between simple and complex structures, but it's easier to explain structures in this way.

#### Defining and Declaring Strucutres
Here's an example of a structure for a graphics program with x and y coordinates.
<pre>
struct coord
{
    int x;
    int y;
};
</pre>
The name of a structure is also known as the structure's _tag_ or _type name_.

There are two ways to declare structures. One is to follow the structure definition with a list of one or more variable names, as is done here:
<pre>
struct coord {
    int x;
    int y;
} first, second;
</pre>
These statements define the structure type ``coord`` and declare two structures, ``first`` and ``second``, of type ``coord``. ``first`` and ``second`` are each _instances_ of type ``coord``; ``first`` contains the two integer members named ``x`` and ``y``, and so does ``second``.

The above method of declaring structures combines the declaration with the defintion. The second method is to declare structure variables at a different location in your source code from the defintion.

<pre>
struct coord {
    int x;
    int y;
}

struct coord first, second;
</pre>

#### Accessing Members of a Structure
Individual structure members can be used like other variables of the same type. Structure members are accessed using the _structure member operator_ (``.``), also called the _dot operator_, between the structure name and the member name. Thus, to have the structure named _first_ refer to a screen location that has coordiantes ``x=50, y=100``, you could write
<pre>
first.x = 50;
first.y = 100;
</pre>
To display the screen locations stored in the structure ``second``, you could write
<pre>
printf("%d,%d", second.x, second.y);
</pre>
At this point, you might wonder what the advantage is of using strucutres rather than individual variables. One major advantage is that you can copy information between structures of the same type with a simple equation statement. Continuing with the preceding example, the statement
<pre>
first = second;
</pre>
is equivalent to this statement:
<pre>
first.x = second.x;
first.y = second.y;
</pre>

When your program uses complex structures with many members, this notation can be a great time-saver. Other advantages of structures will become apparent as you learn some advanced techniques. In general, you'll find structures to be useful whenever information of different variable types should be treated as a group. For example, in a mailing list database, each entry could be a structure, and each piece of information (name, address, city, and so on) could be a structure member.

``simplestruct.c`` pulls together everything that has been covered up to this point. It is not practical; however, it illustrates the point of a simple structure.


## Postgre Connection

Got the postgre header file correctly imported.
Successfully compiled initializing conneciton. Required me to link the library with 'lpb'

Got postgre connection to my localhost working.  
Learning a little bit about this CURSOR idea in postgre. 
Rather than executing a whole query at once, it is possible to set up a _cursor_ that encapsulates the query, and then read the query result a few rows at a time. One reason for doing this is to avoid memory overrun when the result contains a large number of rows. A more interesting usage is to return a reference to a cursor that a function has created, allowing the caller to read the rows. This provides an efficient way to return large row sets from functions.

PQerrorMessage 
<pre>
char *PQerrorMessage(const PGconn *conn);
</pre>
- Returns the error message most recently generated by an operation on the connection.
- I don't understand why the function definition is declared as a pointer
Reading online, it seems that somehow declaring functions are pointers allows one to use the function name in the future and what it's really doing is accessing the pointer location. The location contains all the operators and stuff. But when I declare functions in my C programs this far, I haven't declared them as pointers but rather just functions. Would it break it if I declared my functions are pointers.
Hmm... A big reason I'm doing all this C programming is to try and learn about pointers and these more raw datatypes. So I'll continue to allow myself to be confused... until it makes sense...
I declared my exit_nicely function as a pointer and it didn't appear to change the behavior at all. I wonder when it does change the behavior?
https://www.cprogramming.com/tutorial/function-pointers.html
Benefits of Function pointers
- Function pointers provide a way of passing around instructions for how to do something
- You can write flexible functions and libraries that allow the programmer to choose behavior by passing function pointers as arguments

## What does NOTIFY do in postgre?
<pre>
NOTIFY channel [ , payload ]
</pre>
The ``NOTIFY`` command sends a notification event together with an optional "payload" string to each client application that has previously executed LISTEN **channel** for the specified channel name in the current database.

``NOTIFY`` provides a simple interprocess communication mechanism for a collection of processes accessing the same PostgreSQL database. A payload string can be sent along with the notificaiton, and higher-level mechanisms for passing structured data can be built by using tables in the database to pass additional data from notifier to listener(s).

The information passed to the client for a notification event includes the notification channel name, the notifying session's server process PID, and the payload string, which is an empty string if it has not been specified.

It is up to the database designer to define the channel names that will be used in a given database and what each one means. Commonly, the channel name is the same as the name of some table in the database, and the notify event essentially means, "I changed this table, take a look at it to see what's new". But no such association is enforced by the NOTIFY and LISTEN commands. For example, a database designer could use several different channel names to signal different sorts of changes to a single table. Alternatively, the payload string could be used to differentiate various cases.

When ``NOTIFY`` is used to signal the occurrence of changes to a particular table, a useful programming technique is to put the ``NOTIFY`` in a statement trigger that is triggered by table updates. In this way, notificaiton happens automatically when the table is changed, and the application programmer cannot accidentally forget to do it.

``NOTIFY`` interacts with SQL transactions in some important ways. Firstly, if a ``NOTIFY`` is executed inside a transaction, the notify events are not delivered until and unless the transaction is committed. This is appropriate, since if the transaction is aborted, all the commands within it have had no effect, including ``NOTIFY``. But it can be disconcerting if one is expecting the notification events to be delivered immeditately. Secondly, if a listening session received a notification signal while iti is within a transaction, the notification event will not be delivered to its connected client until just after the transaction is completed (either committed or aborted). Again, the reasoning is that if a notification were delivered within a transaction that was later aborted, one would want the notification to be undone somehow -- but the server cannot "take back" a notification once it has sent it to the client. So notification events are only delivered between transactions. The upshot of this is that applications using ``NOTIFY`` for real-time signaling should try to keep their transactions short.

If the same channel name is signaled multiple times with identical payload strings within the same transaction, only one instance of the notification event is delivered to listeners. On the other hand, notifications with distinct payload strings will always be delivered as distinct notifications. Similarly, notifications from different transactions will never get folded into one notification. Except for dropping later instances of duplicate notifications, ``NOTIFY`` guarantees that notifications from the same transaction get delivered in the order they were sent. It is also guaranteed that messages from different transactions are delivered in the order in which the transactions committed.

It is common for a client that executes ``NOTIFY`` to be listening on the same notification channel itself. In that case it will get back a notification event, just like all the other listening sessions. Depending on the applicaiton logic, this could result in useless work, for example, reading a database table to find the same updates that that session just wrote out. It is possible to avoid such extra work by noticing whether the notifying session's server process PID (supplied in the notification event message) is the same as one's own session's PID (available from libpq). When they are the same, the notification event is one's own work bouncing back, and can be ignored.

### PQfreemem
<pre>
void PQfreemem(void *ptr)
</pre>
Frees memory allocated by libpq.

Frees memory allocated by libpq, particularly PQescapeByteaConn, PQescapeBytea, PQunescapeBytea, and PQnotifies. It is particularly important that this function, rather than ``free()``, be used on Microsoft Windows. This is because allocating memory in a DLL and releasing it in the application works only if multithreaded/single-threaded, release/debug, and static/dynamic flags are the same for the DLL and the application. On non-Microsoft Windows platforms, this function is the same as the standard library function ``free()``.
